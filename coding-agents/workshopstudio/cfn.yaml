Description: Create a code-server instance with an Amazon CloudFront distribution for use in Workshop Studio. Version 5.1.1 - Unified Template

Parameters:
  CodeServerUser:
    Type: String
    Description: UserName for code-server
    Default: coder
  InstanceName:
    Type: String
    Description: Code-server EC2 instance name
    Default: CodeServer
  InstanceVolumeSize:
    Type: Number
    Description: Code-server EC2 instance volume size in GB
    Default: 60
  InstanceType:
    Description: Code-server EC2 instance type
    Type: String
    Default: c7i.4xlarge
  InstanceOperatingSystem:
    Description: Code-server EC2 operating system
    Type: String
    Default: Ubuntu-22
    AllowedValues: ['Ubuntu-22', 'Ubuntu-24']
  HomeFolder:
    Type: String
    Description: Folder to open in code-server
    Default: /work
  DevServerBasePath:
    Type: String
    Description: Base path for the application to be added to Nginx sites-available list
    Default: app
  DevServerPort:
    Type: Number
    Description: Port for the DevServer
    Default: 8081
  AssetZipS3Path:
    Type: String
    Description: S3 URL for the assets zip file
    Default: 's3://ws-assets-prod-iad-r-iad-ed304a55c2ca1aee/91fc619d-afab-4f46-a18e-a1bcf537570b/assets.zip'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Instance Configuration
        Parameters:
          - InstanceName
          - InstanceVolumeSize
          - InstanceType
          - InstanceOperatingSystem
      - Label:
          default: Code-server Configuration
        Parameters:
          - CodeServerUser
          - HomeFolder
          - DevServerBasePath
          - DevServerPort
          - AssetZipS3Path
    ParameterLabels:
      CodeServerUser:
        default: Code-server user name
      InstanceName:
        default: Instance name
      InstanceVolumeSize:
        default: Instance volume size
      InstanceType:
        default: Instance type
      InstanceOperatingSystem:
        default: Instance operating system
      HomeFolder:
        default: Code-server home folder
      DevServerBasePath:
        default: Application base path
      DevServerPort:
        default: Application port
      AssetZipS3Path:
        default: S3 path to assets zip file

Conditions:
  IsGraviton:
    !Not [
      !Equals [
        !Select [0, !Split ['g', !Select [0, !Split ['.', !Ref InstanceType]]]],
        !Select [0, !Split ['.', !Ref InstanceType]],
      ],
    ]

Mappings:
  ArmImage:
    Ubuntu-22:
      ImageId: '{{resolve:ssm:/aws/service/canonical/ubuntu/server/jammy/stable/current/arm64/hvm/ebs-gp2/ami-id}}'
    Ubuntu-24:
      ImageId: '{{resolve:ssm:/aws/service/canonical/ubuntu/server/noble/stable/current/arm64/hvm/ebs-gp3/ami-id}}'
  AmdImage:
    Ubuntu-22:
      ImageId: '{{resolve:ssm:/aws/service/canonical/ubuntu/server/jammy/stable/current/amd64/hvm/ebs-gp2/ami-id}}'
    Ubuntu-24:
      ImageId: '{{resolve:ssm:/aws/service/canonical/ubuntu/server/noble/stable/current/amd64/hvm/ebs-gp3/ami-id}}'
  AWSRegionsPrefixListID:
    ap-northeast-1:
      PrefixList: pl-58a04531
    ap-northeast-2:
      PrefixList: pl-22a6434b
    ap-south-1:
      PrefixList: pl-9aa247f3
    ap-southeast-1:
      PrefixList: pl-31a34658
    ap-southeast-2:
      PrefixList: pl-b8a742d1
    ca-central-1:
      PrefixList: pl-38a64351
    eu-central-1:
      PrefixList: pl-a3a144ca
    eu-north-1:
      PrefixList: pl-fab65393
    eu-west-1:
      PrefixList: pl-4fa04526
    eu-west-2:
      PrefixList: pl-93a247fa
    eu-west-3:
      PrefixList: pl-75b1541c
    sa-east-1:
      PrefixList: pl-5da64334
    us-east-1:
      PrefixList: pl-3b927c52
    us-east-2:
      PrefixList: pl-b6a144df
    us-west-1:
      PrefixList: pl-4ea04527
    us-west-2:
      PrefixList: pl-82a045eb

Resources:
  # ===== Secrets Resources =====
  CodeServerSecret:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W77
            reason: The default KMS Key used by Secrets Manager is appropriate for this password which will be used to log into code-server, which has very limited permissions. In addition this secret will not be required to be shared across accounts
    Type: AWS::SecretsManager::Secret
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      Name: !Sub "${InstanceName}-${AWS::StackName}-${AWS::Region}-${AWS::AccountId}"
      Description: Code-server user details
      GenerateSecretString:
        PasswordLength: 16
        SecretStringTemplate: !Sub '{"username":"${CodeServerUser}"}'
        GenerateStringKey: 'password'
        ExcludePunctuation: true

  SecretPlaintextLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: !Sub lambda.${AWS::URLSuffix}
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AwsSecretsManager
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Ref CodeServerSecret

  SecretPlaintextLambda:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: Warning incorrectly reported. The role associated with the Lambda function has the AWSLambdaBasicExecutionRole managed policy attached, which includes permission to write CloudWatch Logs. See https://docs.aws.amazon.com/aws-managed-policy/latest/reference/AWSLambdaBasicExecutionRole.html
          - id: W89
            reason: CloudFormation custom function does not need the scaffolding of a VPC, to do so would add unnecessary complexity
          - id: W92
            reason: CloudFormation custom function does not need reserved concurrent executions, to do so would add unnecessary complexity
    Properties:
      Description: Return the value of the secret
      Handler: index.lambda_handler
      Runtime: python3.13
      MemorySize: 128
      Timeout: 10
      Architectures:
        - x86_64
      Role: !GetAtt SecretPlaintextLambdaRole.Arn
      Code:
        ZipFile: |
          import boto3
          import json
          import cfnresponse
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def is_valid_json(json_string):
              try:
                  json.loads(json_string)
                  return True
              except json.JSONDecodeError:
                  logger.info(f'Secret is in string format')
                  return False

          def lambda_handler(event, context):
              logger.debug(f'context: {context}')
              try:
                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='No action to take')
                  else:
                      resource_properties = event['ResourceProperties']
                      secret_name = resource_properties['SecretArn']
                      secrets_mgr = boto3.client('secretsmanager')
                      secret = secrets_mgr.get_secret_value(SecretId = secret_name)
                      secret_value = secret['SecretString']

                      responseData = {}
                      if is_valid_json(secret_value):
                          responseData = secret_value
                      else:
                          responseData = {'secret': secret_value}
                      logger.debug(f'responseData: {responseData}')
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData=json.loads(responseData), reason='OK', noEcho=True)
              except Exception as e:
                  logger.error(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=str(e))

  SecretPlaintext:
    Type: Custom::SecretPlaintextLambda
    Properties:
      ServiceToken: !GetAtt SecretPlaintextLambda.Arn
      ServiceTimeout: 15
      SecretArn: !Ref CodeServerSecret

  # ===== EC2 Resources =====
  CDKToolkitPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: CDKToolkitPolicy
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - cloudformation:CreateChangeSet
              - cloudformation:DescribeStacks
              - cloudformation:CreateStack
              - cloudformation:DeleteStack
              - cloudformation:DescribeChangeSet
              - cloudformation:ExecuteChangeSet
              - cloudformation:DeleteChangeSet
            Resource: !Sub 'arn:aws:cloudformation:${AWS::Region}:${AWS::AccountId}:stack/CDKToolkit/*'
      Roles:
        - !Ref CodeServerInstanceBootstrapRole

  CodeServerInstanceBootstrapRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - !Sub ec2.${AWS::URLSuffix}
                - !Sub ssm.${AWS::URLSuffix}
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
        - !Sub arn:${AWS::Partition}:iam::aws:policy/CloudWatchAgentServerPolicy
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonQDeveloperAccess

  CodeServerInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref CodeServerInstanceBootstrapRole

  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: F1000
            reason: All outbound traffic should be allowed from this instance. The EC2 instance is provisioned in the default VPC, which already has this egress rule, and it is not possible to duplicate this egress rule in the default VPC
    Properties:
      GroupDescription: Security Group for code-server - only allow CloudFront ingress
      SecurityGroupIngress:
        - Description: Allow HTTP from com.amazonaws.global.cloudfront.origin-facing
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          SourcePrefixListId:
            !FindInMap [AWSRegionsPrefixListID, !Ref 'AWS::Region', PrefixList]

  CodeServerInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !If
        - IsGraviton
        - !FindInMap [ArmImage, !Ref InstanceOperatingSystem, ImageId]
        - !FindInMap [AmdImage, !Ref InstanceOperatingSystem, ImageId]
      InstanceType: !Ref InstanceType
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeSize: !Ref InstanceVolumeSize
            VolumeType: gp3
            DeleteOnTermination: true
            Encrypted: true
      Monitoring: true
      SecurityGroupIds:
        - !Ref SecurityGroup
      IamInstanceProfile: !Ref CodeServerInstanceProfile
      UserData:
        Fn::Base64: !Sub |
          #cloud-config
          hostname: ${InstanceName}
          runcmd:
            - mkdir -p ${HomeFolder} && chown -R ${CodeServerUser}:${CodeServerUser} ${HomeFolder}
      Tags:
        - Key: Name
          Value: !Ref InstanceName

  # ===== SSM Resources =====
  CodeServerSSMDoc:
    Type: AWS::SSM::Document
    Properties:
      DocumentType: Command
      Content:
        schemaVersion: '2.2'
        description: Bootstrap code-server instance
        parameters:
          CodeServerPassword:
            type: String
            default: !Ref AWS::StackId
        mainSteps:
          - name: InstallCloudWatchAgent
            action: aws:configurePackage
            inputs:
              name: AmazonCloudWatchAgent
              action: Install
          - name: ConfigureCloudWatchAgent
            action: aws:runDocument
            inputs:
              documentType: SSMDocument
              documentPath: AmazonCloudWatch-ManageAgent
              documentParameters:
                action: configure
                mode: ec2
                optionalConfigurationSource: default
                optionalRestart: 'yes'
          - name: InstallAptPackagesApt
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - dpkg --configure -a
                - apt-get -q update && DEBIAN_FRONTEND=noninteractive apt-get install -y -q apt-utils
                - apt-get -q update && DEBIAN_FRONTEND=noninteractive apt-get install -y -q needrestart unattended-upgrades
                - sed -i 's/#$nrconf{kernelhints} = -1;/$nrconf{kernelhints} = 0;/' /etc/needrestart/needrestart.conf
                - sed -i 's/#$nrconf{verbosity} = 2;/$nrconf{verbosity} = 0;/' /etc/needrestart/needrestart.conf
                - sed -i "s/#\$nrconf{restart} = 'i';/\$nrconf{restart} = 'a';/" /etc/needrestart/needrestart.conf
                - echo "Apt helper packages added. Checking configuration"
                - cat /etc/needrestart/needrestart.conf
          - name: InstallBasePackagesApt
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - dpkg --configure -a
                - apt-get -q update && DEBIAN_FRONTEND=noninteractive apt-get install -y -q curl gnupg whois argon2 unzip nginx openssl locales locales-all apt-transport-https ca-certificates software-properties-common python3-pip nodejs npm graphviz jq
          - name: AddUserApt
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - dpkg --configure -a
                - !Sub |
                  if [[ "${CodeServerUser}" == "ubuntu" ]]
                  then
                    echo 'Using existing user: ${CodeServerUser}'
                  else
                    echo 'Adding user: ${CodeServerUser}'
                    adduser --disabled-password --gecos '' ${CodeServerUser}
                    echo "${CodeServerUser}:{{ CodeServerPassword }}" | chpasswd
                    usermod -aG sudo ${CodeServerUser}
                  fi
                - !Sub |
                  tee /etc/sudoers.d/91-vscode-user <<EOF
                  ${CodeServerUser} ALL=(ALL) NOPASSWD:ALL
                  EOF
                - !Sub mkdir -p /home/${CodeServerUser} && chown -R ${CodeServerUser}:${CodeServerUser} /home/${CodeServerUser}
                - !Sub mkdir -p /home/${CodeServerUser}/.local/bin && chown -R ${CodeServerUser}:${CodeServerUser} /home/${CodeServerUser}
                - echo "User added. Checking configuration"
                - !Sub getent passwd ${CodeServerUser}
          - name: UpdateProfile
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - echo LANG=en_US.utf-8 >> /etc/environment
                - echo LC_ALL=en_US.UTF-8 >> /etc/environment
                - !Sub echo 'PATH=$PATH:/home/${CodeServerUser}/.local/bin' >> /home/${CodeServerUser}/.bashrc
                - !Sub echo 'export PATH' >> /home/${CodeServerUser}/.bashrc
                - !Sub echo 'export AWS_REGION=${AWS::Region}' >> /home/${CodeServerUser}/.bashrc
                - !Sub echo 'export AWS_ACCOUNTID=${AWS::AccountId}' >> /home/${CodeServerUser}/.bashrc
                - !Sub echo 'export NEXT_TELEMETRY_DISABLED=1' >> /home/${CodeServerUser}/.bashrc
                - !Sub echo "export PS1='\[\033[01;32m\]\u:\[\033[01;34m\]\w\[\033[00m\]\$ '" >> /home/${CodeServerUser}/.bashrc
                - !Sub chown -R ${CodeServerUser}:${CodeServerUser} /home/${CodeServerUser}
          - name: InstallAWSCLI
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - mkdir -p /tmp
                - curl -fsSL https://awscli.amazonaws.com/awscli-exe-linux-$(uname -m).zip -o /tmp/aws-cli.zip
                - !Sub chown -R ${CodeServerUser}:${CodeServerUser} /tmp/aws-cli.zip
                - unzip -q -d /tmp /tmp/aws-cli.zip
                - sudo /tmp/aws/install
                - rm -rf /tmp/aws
                - echo "AWS CLI installed. Checking configuration"
                - aws --version
          - name: InstallGitApt
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - dpkg --configure -a
                - add-apt-repository ppa:git-core/ppa
                - apt-get -q update && DEBIAN_FRONTEND=noninteractive apt-get install -y -q git
                - !Sub sudo -u ${CodeServerUser} git config --global user.email "coder@example.com"
                - !Sub sudo -u ${CodeServerUser} git config --global user.name "Workshop Coder"
                - !Sub sudo -u ${CodeServerUser} git config --global init.defaultBranch "main"
                - echo "Git installed. Checking configuration"
                - git --version
          - name: DownloadAndSetupAssets
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - !Sub |
                  # Create workshop directory if it doesn't exist
                  mkdir -p ${HomeFolder}
                  chown -R ${CodeServerUser}:${CodeServerUser} ${HomeFolder}

                  # Download assets from S3
                  echo "Downloading assets from ${AssetZipS3Path}..."
                  aws s3 cp ${AssetZipS3Path} /tmp/assets.zip

                  # Extract assets to the workshop directory
                  echo "Extracting assets to ${HomeFolder}..."
                  unzip -o /tmp/assets.zip -d ${HomeFolder}

                  # Set proper permissions
                  chown -R ${CodeServerUser}:${CodeServerUser} ${HomeFolder}

                  # Clean up
                  rm -f /tmp/assets.zip

                  # Verify contents
                  echo "Assets downloaded and extracted to ${HomeFolder}:"
                  ls -la ${HomeFolder}
          - name: ConfigureCodeServer
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - !Sub export HOME=/home/${CodeServerUser}
                - curl -fsSL https://code-server.dev/install.sh | bash -s -- 2>&1
                - !Sub systemctl enable --now code-server@${CodeServerUser} 2>&1
                - !Sub |
                  tee /etc/nginx/conf.d/code-server.conf <<EOF
                  server {
                      listen 80;
                      listen [::]:80;
                      server_name *.cloudfront.net;
                      location / {
                        proxy_pass http://localhost:8080/;
                        proxy_set_header Host \$host;
                        proxy_set_header Upgrade \$http_upgrade;
                        proxy_set_header Connection upgrade;
                        proxy_set_header Accept-Encoding gzip;
                      }
                      location /${DevServerBasePath} {
                        proxy_pass http://localhost:${DevServerPort}/${DevServerBasePath};
                        proxy_set_header Host \$host;
                        proxy_set_header Upgrade \$http_upgrade;
                        proxy_set_header Connection upgrade;
                        proxy_set_header Accept-Encoding gzip;
                      }
                  }
                  EOF
                - !Sub mkdir -p /home/${CodeServerUser}/.config/code-server
                - !Sub |
                  tee /home/${CodeServerUser}/.config/code-server/config.yaml <<EOF
                  cert: false
                  auth: password
                  hashed-password: "$(echo -n {{ CodeServerPassword }} | argon2 $(openssl rand -base64 12) -e)"
                  EOF
                - !Sub mkdir -p /home/${CodeServerUser}/.local/share/code-server/User/
                - !Sub touch /home/${CodeServerUser}/.hushlogin
                - !Sub mkdir -p ${HomeFolder} && chown -R ${CodeServerUser}:${CodeServerUser} ${HomeFolder}
                - !Sub |
                  tee /home/${CodeServerUser}/.local/share/code-server/User/settings.json <<EOF
                  {
                    "extensions.autoUpdate": false,
                    "extensions.autoCheckUpdates": false,
                    "telemetry.telemetryLevel": "off",
                    "security.workspace.trust.startupPrompt": "never",
                    "security.workspace.trust.enabled": false,
                    "security.workspace.trust.banner": "never",
                    "security.workspace.trust.emptyWindow": false,
                    "auto-run-command.rules": [
                      {
                        "command": "workbench.action.terminal.new"
                      }
                    ]
                  }
                  EOF
                - !Sub chown -R ${CodeServerUser}:${CodeServerUser} /home/${CodeServerUser}
                - !Sub systemctl restart code-server@${CodeServerUser}
                - systemctl restart nginx
                - !Sub sudo -u ${CodeServerUser} --login code-server --install-extension AmazonWebServices.aws-toolkit-vscode --force
                - !Sub sudo -u ${CodeServerUser} --login code-server --install-extension AmazonWebServices.amazon-q-vscode --force
                - !Sub sudo -u ${CodeServerUser} --login code-server --install-extension saoudrizwan.claude-dev --force
                - !Sub chown -R ${CodeServerUser}:${CodeServerUser} /home/${CodeServerUser}
                - echo "Nginx installed. Checking configuration"
                - nginx -t 2>&1
                - systemctl status nginx
                - echo "CodeServer installed. Checking configuration"
                - code-server -v
                - !Sub systemctl status code-server@${CodeServerUser}
          - name: SetupCodeCommand
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - |
                  cat > /usr/local/bin/code << EOF
                  #!/bin/bash
                  if [ "\$1" = "." ]; then
                    current_dir=\$(pwd)
                    /usr/bin/code-server \$current_dir
                  elif [ -n "\$1" ]; then
                    target=\$(realpath "\$1" 2>/dev/null || echo "\$1")
                    /usr/bin/code-server \$target
                  fi
                  EOF
                - chmod +x /usr/local/bin/code
          - name: InstallNodeApt
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - apt-get update && apt-get install -y nodejs npm
                - npm install -g n
                - n 22
                - export PATH="/usr/local/bin:$PATH"
                - npm install -g npm@latest
                - echo "Node and npm installed. Checking configuration"
                - node -v
                - npm -v
          - name: Installuv
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - !Sub sudo -u ${CodeServerUser} --login curl -fsSL https://astral.sh/uv/install.sh -o /tmp/uv_install.sh
                - !Sub sudo -u ${CodeServerUser} --login bash /tmp/uv_install.sh
                - !Sub |
                  if uv generate-shell-completion bash &>/dev/null; then
                    echo 'eval "$(uv generate-shell-completion bash)"' >> /home/${CodeServerUser}/.bashrc
                  fi
                - !Sub |
                  if uvx generate-shell-completion bash &>/dev/null; then
                    echo 'eval "$(uvx generate-shell-completion bash)"' >> /home/${CodeServerUser}/.bashrc
                  fi
                - echo "uv installed. Checking configuration"
                - !Sub sudo -u ${CodeServerUser} --login uv --version
          - name: InstallDockerApt
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - dpkg --configure -a
                - curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
                - echo "deb [signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release --codename --short) stable" > /etc/apt/sources.list.d/docker.list
                - apt-get -q update && DEBIAN_FRONTEND=noninteractive apt-get install -y -q docker-ce docker-ce-cli containerd.io
                - !Sub usermod -aG docker ${CodeServerUser}
                - !Sub sudo -u ${CodeServerUser} newgrp docker
                - !Sub systemctl restart code-server@${CodeServerUser}
                - systemctl start docker.service
                - !Sub sudo -u ${CodeServerUser} --login code-server --install-extension ms-azuretools.vscode-docker --force
                - echo "Docker installed. Checking configuration"
                - docker --version
                - systemctl status docker.service
          - name: ConfigureMCPForAmazonQ
            action: aws:runShellScript
            inputs:
              runCommand:
                - '#!/bin/bash'
                - !Sub |
                  mkdir -p /home/${CodeServerUser}/.aws/amazonq
                  cat > /home/${CodeServerUser}/.aws/amazonq/mcp.json << EOF
                  {
                    "mcpServers": {
                      "awslabs.aws-documentation-mcp-server": {
                        "autoApprove": [
                          "read_documentation",
                          "search_documentation",
                          "recommend"
                        ],
                        "disabled": false,
                        "command": "uvx",
                        "args": [
                          "awslabs.aws-documentation-mcp-server@latest"
                        ],
                        "env": {
                          "FASTMCP_LOG_LEVEL": "ERROR"
                        },
                        "transportType": "stdio"
                      }
                    }
                  }
                  EOF
                - !Sub chown -R ${CodeServerUser}:${CodeServerUser} /home/${CodeServerUser}/.aws
          - name: ConfigureMCPForCline
            action: aws:runShellScript
            inputs:
              runCommand:
                - '#!/bin/bash'
                - !Sub |
                  mkdir -p /home/${CodeServerUser}/.local/share/code-server/User/globalStorage/saoudrizwan.claude-dev/settings/
                  cat > /home/${CodeServerUser}/.local/share/code-server/User/globalStorage/saoudrizwan.claude-dev/settings/cline_mcp_settings.json << EOF
                  {
                    "mcpServers": {
                      "awslabs.aws-documentation-mcp-server": {
                        "autoApprove": [
                          "read_documentation",
                          "search_documentation",
                          "recommend"
                        ],
                        "disabled": false,
                        "command": "uvx",
                        "args": [
                          "awslabs.aws-documentation-mcp-server@latest"
                        ],
                        "env": {
                          "FASTMCP_LOG_LEVEL": "ERROR"
                        },
                        "transportType": "stdio"
                      }
                    }
                  }
                  EOF
                  chown -R ${CodeServerUser}:${CodeServerUser} /home/${CodeServerUser}/.local/share/code-server

          - name: ConfigureMCPForKiro
            action: aws:runShellScript
            inputs:
              runCommand:
                - '#!/bin/bash'
                - !Sub |
                  mkdir -p /home/${CodeServerUser}/.kiro/settings
                  cat > /home/${CodeServerUser}/.kiro/settings/mcp.json << EOF
                  {
                    "mcpServers": {
                      "awslabs.aws-documentation-mcp-server": {
                        "autoApprove": [
                          "read_documentation",
                          "search_documentation",
                          "recommend"
                        ],
                        "disabled": false,
                        "command": "uvx",
                        "args": [
                          "awslabs.aws-documentation-mcp-server@latest"
                        ],
                        "env": {
                          "FASTMCP_LOG_LEVEL": "ERROR"
                        }
                      }
                    }
                  }
                  EOF
                  chown -R ${CodeServerUser}:${CodeServerUser} /home/${CodeServerUser}/.kiro

  # ===== Lambda Resources =====
  SSMDocLambdaRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: The Amazon EC2 ssm:*CommandInvocation API actions do not support resource-level permissions, so you cannot control which individual resources users can view in the console. Therefore, the * wildcard is necessary in the Resource element. See https://docs.aws.amazon.com/service-authorization/latest/reference/list_awssystemsmanager.html
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: !Sub lambda.${AWS::URLSuffix}
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SSMDocOnEC2
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ssm:SendCommand
                Resource:
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:document/${CodeServerSSMDoc}
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:document/AmazonCloudWatch-ManageAgent
                  - !Sub arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:instance/${CodeServerInstance}
              - Effect: Allow
                Action:
                  - ssm:ListCommandInvocations
                  - ssm:GetCommandInvocation
                Resource: '*'

  RunSSMDocLambda:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: Warning incorrectly reported. The role associated with the Lambda function has the AWSLambdaBasicExecutionRole managed policy attached, which includes permission to write CloudWatch Logs.
          - id: W89
            reason: CloudFormation custom function does not need the scaffolding of a VPC, to do so would add unnecessary complexity
          - id: W92
            reason: CloudFormation custom function does not need reserved concurrent executions, to do so would add unnecessary complexity
    Properties:
      Description: Run SSM document on EC2 instance
      Handler: index.lambda_handler
      Runtime: python3.13
      MemorySize: 128
      Timeout: 900
      Environment:
        Variables:
          RetrySleep: 2900
          AbortTimeRemaining: 3200
      Architectures:
        - x86_64
      Role: !GetAtt SSMDocLambdaRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          import time
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.debug(f'context: {context}')

              if event['RequestType'] != 'Create':
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='No action to take')
              else:
                  sleep_ms = int(os.environ.get('RetrySleep'))
                  abort_time_remaining_ms = int(os.environ.get('AbortTimeRemaining'))
                  resource_properties = event['ResourceProperties']
                  instance_id = resource_properties['InstanceId']
                  document_name = resource_properties['DocumentName']
                  cloudwatch_log_group_name = resource_properties['CloudWatchLogGroupName']

                  logger.info(f'Running SSM Document {document_name} on EC2 instance {instance_id}. Logging to {cloudwatch_log_group_name}')

                  del resource_properties['ServiceToken']
                  if 'ServiceTimeout' in resource_properties:
                      del resource_properties['ServiceTimeout']
                  del resource_properties['InstanceId']
                  del resource_properties['DocumentName']
                  del resource_properties['CloudWatchLogGroupName']
                  if 'PhysicalResourceId' in resource_properties:
                      del resource_properties['PhysicalResourceId']

                  parameters = {}
                  for key, value in resource_properties.items():
                      parameters[key] = [value]
                  retry = True
                  attempt_no = 0
                  time_remaining_ms = context.get_remaining_time_in_millis()

                  ssm = boto3.client('ssm')

                  while (retry == True):
                      attempt_no += 1
                      logger.info(f'Attempt: {attempt_no}. Time Remaining: {time_remaining_ms/1000}s')
                      try:
                          response = ssm.send_command(
                              InstanceIds = [instance_id],
                              DocumentName = document_name,
                              CloudWatchOutputConfig = {'CloudWatchLogGroupName': cloudwatch_log_group_name, 'CloudWatchOutputEnabled': True},
                              Parameters = parameters
                          )
                          command_id = response['Command']['CommandId']
                          responseData = {'CommandId': command_id}
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, reason='OK')
                          retry = False

                      except ssm.exceptions.InvalidInstanceId as e:
                          time_remaining_ms = context.get_remaining_time_in_millis()
                          if (time_remaining_ms > abort_time_remaining_ms):
                              logger.info(f'Instance {instance_id} not ready. Sleeping: {sleep_ms/1000}s')
                              time.sleep(sleep_ms/1000)
                              retry = True
                          else:
                              logger.info(f'Instance {instance_id} not ready, timed out. Time remaining {time_remaining_ms/1000}s < Abort time remaining {abort_time_remaining_ms/1000}s')
                              logger.error(e, exc_info=True)
                              cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason='Timed out. Time remaining: ' + str(time_remaining_ms/1000) + 's < Abort time remaining: ' + str(abort_time_remaining_ms/1000) + 's')
                              retry = False

                      except Exception as e:
                          logger.error(e, exc_info=True)
                          cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=str(e))
                          retry = False

  CodeServerHealthCheckLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: !Sub lambda.${AWS::URLSuffix}
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  CodeServerHealthCheckLambda:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: Warning incorrectly reported.
          - id: W89
            reason: CloudFormation custom function does not need the scaffolding of a VPC
          - id: W92
            reason: CloudFormation custom function does not need reserved concurrent executions
    Properties:
      Description: Run health check on code-server instance
      Handler: index.lambda_handler
      Runtime: python3.13
      MemorySize: 128
      Timeout: 900
      Environment:
        Variables:
          RetrySleep: 2900
          AbortTimeRemaining: 5000
      Architectures:
        - x86_64
      Role: !GetAtt CodeServerHealthCheckLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import cfnresponse
          import logging
          import time
          import os
          import http.client
          from urllib.parse import urlparse

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def healthURLOk(url):
              try:
                  logger.debug(f'url: {url}')
                  parsed_url = urlparse(url)
                  if parsed_url.scheme == 'https':
                      conn = http.client.HTTPSConnection(parsed_url.netloc)
                  else:
                      conn = http.client.HTTPConnection(parsed_url.netloc)
                  conn.request("GET", parsed_url.path or "/")
                  response = conn.getresponse()
                  content = response.read()
                  if 200 <= response.status < 400:
                      response_dict = json.loads(content.decode('utf-8'))
                      if 'status' in response_dict and (response_dict['status'].lower() == 'alive' or response_dict['status'].lower() == 'expired'):
                          logger.info(f'Health check OK. Status: {response_dict["status"].lower()}')
                          return True
                      else:
                          logger.info(f'Health check failed. Status: {response_dict.get("status", "unknown")}')
                          return False
                  else:
                      logger.info(f'Healthcheck failed. Return code: {response.status}')
                      return False
              except Exception as e:
                  logger.error(e, exc_info=True)
                  return False
              finally:
                  if 'conn' in locals():
                      conn.close()

          def lambda_handler(event, context):
              try:
                  if event['RequestType'] != 'Create':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='No action to take')
                  else:
                      sleep_ms = int(os.environ.get('RetrySleep'))
                      abort_time_remaining_ms = int(os.environ.get('AbortTimeRemaining'))
                      resource_properties = event['ResourceProperties']
                      url = resource_properties['Url']

                      time_remaining_ms = context.get_remaining_time_in_millis()
                      attempt_no = 0
                      health_check = False
                      while (attempt_no == 0 or (time_remaining_ms > abort_time_remaining_ms and not health_check)):
                          attempt_no += 1
                          logger.info(f'Attempt: {attempt_no}. Time Remaining: {time_remaining_ms/1000}s')
                          health_check = healthURLOk(url)
                          if not health_check:
                              time.sleep(sleep_ms/1000)
                          time_remaining_ms = context.get_remaining_time_in_millis()
                      if health_check:
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='Code-server healthcheck successful')
                      else:
                          cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason='Code-server healthcheck failed')
              except Exception as e:
                  logger.error(e, exc_info=True)
                  cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=str(e))

  CheckSSMDocLambda:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: Warning incorrectly reported.
          - id: W89
            reason: CloudFormation custom function does not need the scaffolding of a VPC
          - id: W92
            reason: CloudFormation custom function does not need reserved concurrent executions
    Properties:
      Description: Check SSM document on EC2 instance
      Handler: index.lambda_handler
      Runtime: python3.13
      MemorySize: 128
      Timeout: 900
      Environment:
        Variables:
          RetrySleep: 2900
          AbortTimeRemaining: 5000
      Architectures:
        - x86_64
      Role: !GetAtt SSMDocLambdaRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          import time
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              if event['RequestType'] != 'Create':
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='No action to take')
              else:
                  sleep_ms = int(os.environ.get('RetrySleep'))
                  abort_time_remaining_ms = int(os.environ.get('AbortTimeRemaining'))
                  resource_properties = event['ResourceProperties']
                  instance_id = resource_properties['InstanceId']
                  document_name = resource_properties['DocumentName']

                  retry = True
                  attempt_no = 0
                  time_remaining_ms = context.get_remaining_time_in_millis()
                  ssm = boto3.client('ssm')

                  while (retry == True):
                      attempt_no += 1
                      try:
                          response = ssm.list_command_invocations(InstanceId=instance_id, Details=True)
                          for invocation in response['CommandInvocations']:
                              if invocation['DocumentName'] == document_name:
                                  invocation_status = invocation['Status']
                                  if invocation_status == 'Success':
                                      cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='OK')
                                      retry = False
                                  elif invocation_status in ['Failed', 'Cancelled', 'TimedOut']:
                                      reason = f'SSM Document {document_name} failed with status: {invocation_status}'
                                      cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=reason)
                                      retry = False
                          if retry == True:
                              if (time_remaining_ms > abort_time_remaining_ms):
                                  time.sleep(sleep_ms/1000)
                                  time_remaining_ms = context.get_remaining_time_in_millis()
                              else:
                                  cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason='Timed out')
                                  retry = False
                      except Exception as e:
                          logger.error(e, exc_info=True)
                          cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=str(e))
                          retry = False

  # ===== CloudFront Resources =====
  CodeServerInstanceCachePolicy:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        DefaultTTL: 86400
        MaxTTL: 31536000
        MinTTL: 1
        Name: !Sub
          - ${InstanceName}-${RandomGUID}
          - RandomGUID:
              !Select [
                0,
                !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]],
              ]
        ParametersInCacheKeyAndForwardedToOrigin:
          CookiesConfig:
            CookieBehavior: all
          EnableAcceptEncodingGzip: False
          HeadersConfig:
            HeaderBehavior: whitelist
            Headers:
              - Accept-Charset
              - Authorization
              - Origin
              - Accept
              - Referer
              - Host
              - Accept-Language
              - Accept-Encoding
              - Accept-Datetime
          QueryStringsConfig:
            QueryStringBehavior: all

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W10
            reason: CloudFront Distribution access logging would require setup of an S3 bucket
          - id: W70
            reason: Workshop Studio does not include a domain that can be used to provision a certificate
    Properties:
      DistributionConfig:
        Enabled: True
        HttpVersion: http2and3
        CacheBehaviors:
          - AllowedMethods:
              - GET
              - HEAD
              - OPTIONS
              - PUT
              - PATCH
              - POST
              - DELETE
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad
            Compress: False
            OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3
            TargetOriginId: !Sub CloudFront-${AWS::StackName}
            ViewerProtocolPolicy: allow-all
            PathPattern: '/proxy/*'
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
            - PUT
            - PATCH
            - POST
            - DELETE
          CachePolicyId: !Ref CodeServerInstanceCachePolicy
          OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3
          TargetOriginId: !Sub CloudFront-${AWS::StackName}
          ViewerProtocolPolicy: allow-all
        Origins:
          - DomainName: !GetAtt CodeServerInstance.PublicDnsName
            Id: !Sub CloudFront-${AWS::StackName}
            CustomOriginConfig:
              OriginProtocolPolicy: http-only

  # ===== Custom Resources =====
  RunCodeServerSSMDoc:
    Type: Custom::RunSSMDocLambda
    Properties:
      ServiceToken: !GetAtt RunSSMDocLambda.Arn
      ServiceTimeout: 305
      InstanceId: !Ref CodeServerInstance
      DocumentName: !Ref CodeServerSSMDoc
      CloudWatchLogGroupName: !Sub /aws/ssm/${CodeServerSSMDoc}
      CodeServerPassword: !GetAtt SecretPlaintext.password

  Healthcheck:
    Type: Custom::CodeServerHealthCheckLambda
    Properties:
      ServiceToken: !GetAtt CodeServerHealthCheckLambda.Arn
      ServiceTimeout: 2400
      Url: !Sub https://${CloudFrontDistribution.DomainName}/healthz

Outputs:
  URL:
    Description: Code-server URL
    Value: !Sub https://${CloudFrontDistribution.DomainName}/?folder=${HomeFolder}
  Password:
    Description: Code-server Password
    Value: !GetAtt SecretPlaintext.password
