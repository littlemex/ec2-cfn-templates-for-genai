AWSTemplateFormatVersion: '2010-09-09'
Description: VS Code Server with Complete Cognito Setup - Just provide email and password!

Parameters:
  # üéØ „Åì„Çå„Å†„ÅëË®≠ÂÆö„Åô„Çå„Å∞OKÔºÅ
  AdminEmail:
    Type: String
    Description: Admin user email address for login
    AllowedPattern: ^[^\s@]+@[^\s@]+\.[^\s@]+$
    ConstraintDescription: Must be a valid email address
  
  AdminPassword:
    Type: String
    Description: Admin user password (minimum 8 characters)
    NoEcho: true
    MinLength: 8
    AllowedPattern: ^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&._-]{8,}$
    ConstraintDescription: Must contain at least 8 characters with uppercase, lowercase, and number
  
  # Âü∫Êú¨Ë®≠ÂÆöÔºàÊó¢Â≠ò„Åã„ÇâÊµÅÁî®Ôºâ
  CodeServerUser:
    Type: String
    Description: UserName for code-server
    Default: participant
  
  InstanceName:
    Type: String
    Description: Code-server EC2 instance name
    Default: CodeServerInstance
  
  InstanceVolumeSize:
    Type: Number
    Description: Code-server EC2 instance volume size in GB
    Default: 40
  
  InstanceType:
    Description: Code-server EC2 instance type
    Type: String
    Default: c7i.4xlarge
  
  InstanceOperatingSystem:
    Description: Code-server EC2 operating system
    Type: String
    Default: Ubuntu-22
    AllowedValues: ['Ubuntu-22', 'Ubuntu-24']
  
  HomeFolder:
    Type: String
    Description: Folder to open in code-server
    Default: /workshop
  
  DevServerBasePath:
    Type: String
    Description: Base path for the application
    Default: app
  
  DevServerPort:
    Type: Number
    Description: Port for the DevServer
    Default: 8081
  
  RepoUrl:
    Description: Remote repo URL to clone
    Type: String
    Default: ''
  
  AssetZipS3Path:
    Description: S3 path for workshop assets
    Type: String
    Default: https://ws-assets-prod-iad-r-pdx-f3b3f9f1a7d6a3d0.s3.us-west-2.amazonaws.com/33b9f640-2cab-47f0-bfdd-d3aab3c38eee/bedrock-agent-knowledge-base-actions-workshop-main-wsstudio.zip

Conditions:
  IsAL2023: !Equals [!Ref InstanceOperatingSystem, 'AmazonLinux-2023']
  IsGraviton:
    !Not [!Equals [!Select [0, !Split ['g', !Select [0, !Split ['.', !Ref InstanceType]]]],
                   !Select [0, !Split ['.', !Ref InstanceType]],],]

Mappings:
  ArmImage:
    Ubuntu-22:
      ImageId: '{{resolve:ssm:/aws/service/canonical/ubuntu/server/jammy/stable/current/arm64/hvm/ebs-gp2/ami-id}}'
    Ubuntu-24:
      ImageId: '{{resolve:ssm:/aws/service/canonical/ubuntu/server/noble/stable/current/arm64/hvm/ebs-gp3/ami-id}}'
    AmazonLinux-2023:
      ImageId: '{{resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-arm64}}'
  
  AmdImage:
    Ubuntu-22:
      ImageId: '{{resolve:ssm:/aws/service/canonical/ubuntu/server/jammy/stable/current/amd64/hvm/ebs-gp2/ami-id}}'
    Ubuntu-24:
      ImageId: '{{resolve:ssm:/aws/service/canonical/ubuntu/server/noble/stable/current/amd64/hvm/ebs-gp3/ami-id}}'
    AmazonLinux-2023:
      ImageId: '{{resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64}}'
  
  AWSRegionsPrefixListID:
    ap-northeast-1:
      PrefixList: pl-58a04531
    ap-northeast-2:
      PrefixList: pl-22a6434b
    ap-south-1:
      PrefixList: pl-9aa247f3
    ap-southeast-1:
      PrefixList: pl-31a34658
    ap-southeast-2:
      PrefixList: pl-b8a742d1
    ca-central-1:
      PrefixList: pl-38a64351
    eu-central-1:
      PrefixList: pl-a3a144ca
    eu-north-1:
      PrefixList: pl-fab65393
    eu-west-1:
      PrefixList: pl-4fa04526
    eu-west-2:
      PrefixList: pl-93a247fa
    eu-west-3:
      PrefixList: pl-75b1541c
    sa-east-1:
      PrefixList: pl-5da64334
    us-east-1:
      PrefixList: pl-3b927c52
    us-east-2:
      PrefixList: pl-b6a144df
    us-west-1:
      PrefixList: pl-4ea04527
    us-west-2:
      PrefixList: pl-82a045eb

Resources:
  # üöÄ Cognito User Pool Ëá™Âãï‰ΩúÊàê
  CognitoUserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub ${AWS::StackName}-workshop-users
      # „ÉØ„Éº„ÇØ„Ç∑„Éß„ÉÉ„ÉóÁî®„ÅÆÁ∞°ÂçòË®≠ÂÆö
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireUppercase: true
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: false
          TemporaryPasswordValidityDays: 1
      # „É°„Éº„É´Ë®≠ÂÆö
      AutoVerifiedAttributes:
        - email
      UsernameAttributes:
        - email
      # „ÉØ„Éº„ÇØ„Ç∑„Éß„ÉÉ„ÉóÁî®„ÅÆÁ∞°Âçò„Å™„É°„Éº„É´Ë®≠ÂÆö
      EmailConfiguration:
        EmailSendingAccount: COGNITO_DEFAULT
      # „É¶„Éº„Ç∂„ÉºÁôªÈå≤Ë®≠ÂÆö
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: true  # ÁÆ°ÁêÜËÄÖ„ÅÆ„Åø„Åå„É¶„Éº„Ç∂„Éº‰ΩúÊàêÂèØËÉΩ
      # Â±ûÊÄßË®≠ÂÆö
      Schema:
        - Name: email
          AttributeDataType: String
          Required: true
          Mutable: true
      UserPoolTags:
        Purpose: Workshop
        CreatedBy: CloudFormation

  # üîß Cognito User Pool Domain Ëá™Âãï‰ΩúÊàê
  CognitoUserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      Domain: !Sub ${AWS::StackName}-workshop-${AWS::AccountId}
      UserPoolId: !Ref CognitoUserPool

  # üì± Cognito App Client Ëá™Âãï‰ΩúÊàêÔºàÂàùÊúüÁâàÔºâ
  CognitoUserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: !Sub ${AWS::StackName}-workshop-client
      UserPoolId: !Ref CognitoUserPool
      # OAuthË®≠ÂÆöÔºàÊúÄÂàù„Åã„ÇâË®≠ÂÆöÔºâ
      AllowedOAuthFlows:
        - code
      AllowedOAuthScopes:
        - openid
        - email
        - profile
      AllowedOAuthFlowsUserPoolClient: true
      CallbackURLs:
        - https://example.com/callback  # ‰∏ÄÊôÇÁöÑ„Å™URLÔºàUpdateCognitoClient„ÅßÊõ¥Êñ∞Ôºâ
        - https://localhost/oauth/callback  # „É≠„Éº„Ç´„É´„ÉÜ„Çπ„ÉàÁî®
      LogoutURLs:
        - https://example.com/  # ‰∏ÄÊôÇÁöÑ„Å™URLÔºàUpdateCognitoClient„ÅßÊõ¥Êñ∞Ôºâ
        - https://localhost/  # „É≠„Éº„Ç´„É´„ÉÜ„Çπ„ÉàÁî®
      # „Çª„Ç≠„É•„É™„ÉÜ„Ç£Ë®≠ÂÆö
      GenerateSecret: true
      PreventUserExistenceErrors: ENABLED
      # „Éà„Éº„ÇØ„É≥Ë®≠ÂÆöÔºà„ÉØ„Éº„ÇØ„Ç∑„Éß„ÉÉ„ÉóÁî®Ôºâ
      AccessTokenValidity: 1  # 1ÊôÇÈñì
      IdTokenValidity: 1      # 1ÊôÇÈñì
      RefreshTokenValidity: 1 # 1Êó•
      TokenValidityUnits:
        AccessToken: hours
        IdToken: hours
        RefreshToken: days
      # Ë™çË®º„Éï„É≠„Éº
      ExplicitAuthFlows:
        - ALLOW_ADMIN_USER_PASSWORD_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
      SupportedIdentityProviders:
        - COGNITO

  # Cognito App ClientÊõ¥Êñ∞Áî®Lambda
  UpdateCognitoClientLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CognitoUpdatePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - cognito-idp:UpdateUserPoolClient
                Resource: !GetAtt CognitoUserPool.Arn

  UpdateCognitoClientLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-update-cognito-client
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt UpdateCognitoClientLambdaRole.Arn
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def lambda_handler(event, context):
              try:
                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                  
                  user_pool_id = event['ResourceProperties']['UserPoolId']
                  client_id = event['ResourceProperties']['ClientId']
                  cloudfront_domain = event['ResourceProperties']['CloudFrontDomain']
                  
                  cognito = boto3.client('cognito-idp')
                  
                  # App Client„ÇíÊõ¥Êñ∞„Åó„Å¶CloudFront„Éâ„É°„Ç§„É≥„Å®OAuthË®≠ÂÆö„ÇíË®≠ÂÆö
                  cognito.update_user_pool_client(
                      UserPoolId=user_pool_id,
                      ClientId=client_id,
                      CallbackURLs=[
                          f'https://{cloudfront_domain}/oauth/callback'
                      ],
                      LogoutURLs=[
                          f'https://{cloudfront_domain}/'
                      ],
                      AllowedOAuthFlows=['code'],
                      AllowedOAuthScopes=['openid', 'email', 'profile'],
                      AllowedOAuthFlowsUserPoolClient=True,
                      SupportedIdentityProviders=['COGNITO']
                  )
                  
                  logger.info(f'Updated Cognito client with CloudFront domain: {cloudfront_domain}')
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  
              except Exception as e:
                  logger.error(f'Error: {str(e)}')
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, str(e))

  UpdateCognitoClient:
    Type: Custom::UpdateCognitoClient
    DependsOn: CloudFrontDistribution
    Properties:
      ServiceToken: !GetAtt UpdateCognitoClientLambda.Arn
      UserPoolId: !Ref CognitoUserPool
      ClientId: !Ref CognitoUserPoolClient
      CloudFrontDomain: !GetAtt CloudFrontDistribution.DomainName

  # ÔøΩ ÁÆ°ÁêÜÁêÜËÄÖ„É¶„Éº„Ç∂„Éº„ÅÆ‰ΩúÊàê„Å®„Éë„Çπ„ÉØ„Éº„ÉâË®≠ÂÆö
  SetPermanentPasswordLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CognitoAdminPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - cognito-idp:AdminSetUserPassword
                  - cognito-idp:AdminUpdateUserAttributes
                  - cognito-idp:AdminCreateUser
                  - cognito-idp:AdminGetUser
                Resource: !GetAtt CognitoUserPool.Arn

  SetPermanentPasswordLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-set-permanent-password
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt SetPermanentPasswordLambdaRole.Arn
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def lambda_handler(event, context):
              try:
                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                  
                  user_pool_id = event['ResourceProperties']['UserPoolId']
                  username = event['ResourceProperties']['Username']
                  password = event['ResourceProperties']['Password']
                  email = event['ResourceProperties']['Email']
                  
                  cognito = boto3.client('cognito-idp')
                  
                  try:
                      # „É¶„Éº„Ç∂„Éº„ÅåÂ≠òÂú®„Åô„Çã„ÅãÁ¢∫Ë™ç
                      response = cognito.admin_get_user(
                          UserPoolId=user_pool_id,
                          Username=username
                      )
                      logger.info(f'User {username} already exists')
                  except Exception as e:
                      if 'UserNotFoundException' in str(e):
                          # „É¶„Éº„Ç∂„Éº„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàê
                          logger.info(f'User {username} not found, creating new user')
                          cognito.admin_create_user(
                              UserPoolId=user_pool_id,
                              Username=username,
                              UserAttributes=[
                                  {
                                      'Name': 'email',
                                      'Value': email
                                  },
                                  {
                                      'Name': 'email_verified',
                                      'Value': 'true'
                                  }
                              ],
                              MessageAction='SUPPRESS'
                          )
                          logger.info(f'Created user: {username}')
                      else:
                          logger.error(f'Error checking user existence: {str(e)}')
                          raise e
                  
                  # „Éë„Çπ„ÉØ„Éº„Éâ„ÇíÊ∞∏Á∂öÂåñ
                  cognito.admin_set_user_password(
                      UserPoolId=user_pool_id,
                      Username=username,
                      Password=password,
                      Permanent=True
                  )
                  
                  logger.info(f'Successfully set permanent password for user: {username}')
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  
              except Exception as e:
                  logger.error(f'Error: {str(e)}')
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, str(e))

  SetPermanentPassword:
    Type: Custom::SetPermanentPassword
    Properties:
      ServiceToken: !GetAtt SetPermanentPasswordLambda.Arn
      UserPoolId: !Ref CognitoUserPool
      Username: !Ref AdminEmail
      Password: !Ref AdminPassword
      Email: !Ref AdminEmail

  # üîê App Client Secret ÂèñÂæóÁî®Lambda
  GetClientSecretLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CognitoDescribePolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - cognito-idp:DescribeUserPoolClient
                Resource: !GetAtt CognitoUserPool.Arn

  GetClientSecretLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-get-client-secret
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt GetClientSecretLambdaRole.Arn
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def lambda_handler(event, context):
              try:
                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                  
                  user_pool_id = event['ResourceProperties']['UserPoolId']
                  client_id = event['ResourceProperties']['ClientId']
                  
                  cognito = boto3.client('cognito-idp')
                  
                  response = cognito.describe_user_pool_client(
                      UserPoolId=user_pool_id,
                      ClientId=client_id
                  )
                  
                  client_secret = response['UserPoolClient']['ClientSecret']
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                      'ClientSecret': client_secret
                  })
                  
              except Exception as e:
                  logger.error(f'Error: {str(e)}')
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, str(e))

  GetClientSecret:
    Type: Custom::GetClientSecret
    Properties:
      ServiceToken: !GetAtt GetClientSecretLambda.Arn
      UserPoolId: !Ref CognitoUserPool
      ClientId: !Ref CognitoUserPoolClient

  # Êó¢Â≠ò„ÅÆEC2Èñ¢ÈÄ£„É™„ÇΩ„Éº„ÇπÔºàÊµÅÁî®Ôºâ
  CodeServerInstanceBootstrapRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - !Sub ec2.${AWS::URLSuffix}
                - !Sub ssm.${AWS::URLSuffix}
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess  # „ÉØ„Éº„ÇØ„Ç∑„Éß„ÉÉ„ÉóÁî®
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
        - !Sub arn:${AWS::Partition}:iam::aws:policy/CloudWatchAgentServerPolicy
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonQDeveloperAccess

  CodeServerInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref CodeServerInstanceBootstrapRole

  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group for code-server - CloudFront ingress and outbound access
      SecurityGroupIngress:
        - Description: Allow HTTP from com.amazonaws.global.cloudfront.origin-facing
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          SourcePrefixListId:
            !FindInMap [AWSRegionsPrefixListID, !Ref 'AWS::Region', PrefixList]

  # CloudFrontÔºàÂÖà„Å´‰ΩúÊàê„Åó„Å¶„Éâ„É°„Ç§„É≥Âêç„ÇíÂèñÂæóÔºâ
  CodeServerInstanceCachePolicy:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        DefaultTTL: 86400
        MaxTTL: 31536000
        MinTTL: 1
        Name: !Sub
          - ${InstanceName}-${RandomGUID}
          - RandomGUID:
              !Select [0,
                !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]],]
        ParametersInCacheKeyAndForwardedToOrigin:
          CookiesConfig:
            CookieBehavior: all
          EnableAcceptEncodingGzip: False
          HeadersConfig:
            HeaderBehavior: whitelist
            Headers:
              - Accept-Charset
              - Authorization
              - Origin
              - Accept
              - Referer
              - Host
              - Accept-Language
              - Accept-Encoding
              - Accept-Datetime
          QueryStringsConfig:
            QueryStringBehavior: all

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: True
        HttpVersion: http2and3
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
            - PUT
            - PATCH
            - POST
            - DELETE
          CachePolicyId: !Ref CodeServerInstanceCachePolicy
          OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3
          TargetOriginId: !Sub CloudFront-${AWS::StackName}
          ViewerProtocolPolicy: allow-all
        Origins:
          - DomainName: !GetAtt CodeServerInstance.PublicDnsName
            Id: !Sub CloudFront-${AWS::StackName}
            CustomOriginConfig:
              OriginProtocolPolicy: http-only

  # SSM DocumentÔºàCognitoÊÉÖÂ†±„ÇíËá™ÂãïË®≠ÂÆöÔºâ
  CodeServerSSMDoc:
    Type: AWS::SSM::Document
    Properties:
      DocumentType: Command
      Content:
        schemaVersion: '2.2'
        description: Bootstrap VS Code Server with Auto-Generated Cognito Auth
        parameters:
          LinuxFlavor:
            type: String
            default: 'ubuntu'
          CodeServerUser:
            type: String
          CognitoClientId:
            type: String
          CognitoClientSecret:
            type: String
          CognitoUserPoolDomain:
            type: String
          CloudFrontDomain:
            type: String
          DevServerBasePath:
            type: String
          DevServerPort:
            type: String
          HomeFolder:
            type: String
          AssetZipS3Path:
            type: String
        mainSteps:
          # Âü∫Êú¨„Éë„ÉÉ„Ç±„Éº„Ç∏„Ç§„É≥„Çπ„Éà„Éº„É´ÔºàUbuntuÁî®Ôºâ
          - name: InstallBasePackages
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - set -e
                - echo "Updating package lists..."
                - apt-get -q update
                - echo "Installing base packages..."
                - DEBIAN_FRONTEND=noninteractive apt-get install -y -q curl gnupg whois unzip openssl python3-pip nodejs npm snapd
                - echo "Enabling snapd..."
                - systemctl enable --now snapd
                - sleep 10
                - echo "Creating snap symlink..."
                - ln -sf /var/lib/snapd/snap /snap
                - echo "Base packages installation completed"
          
          # „É¶„Éº„Ç∂„Éº‰ΩúÊàêÔºàUbuntuÁî®Ôºâ
          - name: AddUser
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - set -e
                - echo "Setting up user {{ CodeServerUser }}..."
                - |
                  if [[ "{{ CodeServerUser }}" != "ubuntu" ]]; then
                    adduser --disabled-password --gecos '' {{ CodeServerUser }}
                    usermod -aG sudo {{ CodeServerUser }}
                    echo "{{ CodeServerUser }} ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/91-vscode-user
                  fi
                  mkdir -p /home/{{ CodeServerUser }}
                  chown -R {{ CodeServerUser }}:{{ CodeServerUser }} /home/{{ CodeServerUser }}
                  echo "User setup completed"
          
          # VS Code Server „Ç§„É≥„Çπ„Éà„Éº„É´
          - name: InstallVSCodeServer
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - set -e
                - echo "Installing VS Code Server via snap..."
                - snap install --classic code
                - echo "Verifying VS Code Server installation..."
                - /snap/bin/code --version
                - echo "VS Code Server installation completed"
          
          # Á∞°Âçò„Å™Ë™çË®º„Éó„É≠„Ç≠„Ç∑„Çµ„Éº„Éì„Çπ‰ΩúÊàê
          - name: CreateSimpleAuthProxy
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - set -e
                - echo "Creating simple auth proxy server..."
                - |
                  cat > /home/{{ CodeServerUser }}/simple-server.js << 'EOF'
                  const http = require('http');
                  const https = require('https');
                  const url = require('url');
                  const querystring = require('querystring');
                  const crypto = require('crypto');
                  const { spawn } = require('child_process');
                  
                  const CLIENT_ID = process.env.COGNITO_CLIENT_ID;
                  const CLIENT_SECRET = process.env.COGNITO_CLIENT_SECRET;
                  const USER_POOL_DOMAIN = process.env.COGNITO_USER_POOL_DOMAIN;
                  const CLOUDFRONT_DOMAIN = process.env.CLOUDFRONT_DOMAIN;
                  
                  console.log('Server starting with config:');
                  console.log('CLIENT_ID:', CLIENT_ID ? 'SET' : 'NOT SET');
                  console.log('USER_POOL_DOMAIN:', USER_POOL_DOMAIN || 'NOT SET');
                  console.log('CLOUDFRONT_DOMAIN:', CLOUDFRONT_DOMAIN || 'NOT SET');
                  console.log('CLIENT_SECRET:', CLIENT_SECRET ? 'SET' : 'NOT SET');
                  
                  if (!CLIENT_ID || !CLIENT_SECRET || !USER_POOL_DOMAIN || !CLOUDFRONT_DOMAIN) {
                    console.error('Missing required environment variables');
                    process.exit(1);
                  }
                  
                  // Á∞°Âçò„Å™„Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ
                  const sessions = new Map();
                  
                  function generateSessionId() {
                    return crypto.randomBytes(16).toString('hex');
                  }
                  
                  function isValidSession(sessionId) {
                    const session = sessions.get(sessionId);
                    if (!session) return false;
                    if (Date.now() - session.created > 3600000) {
                      sessions.delete(sessionId);
                      return false;
                    }
                    return true;
                  }
                  
                  function checkAuth(req) {
                    const cookies = req.headers.cookie || '';
                    const sessionMatch = cookies.match(/workshop_session=([^;]+)/);
                    return sessionMatch && isValidSession(sessionMatch[1]);
                  }
                  
                  // VS Code Server„Çí/workshop„Éï„Ç©„É´„ÉÄ„ÅßËµ∑Âãï
                  console.log('Starting VS Code Server with /workshop folder...');
                  const vscode = spawn('/snap/bin/code', [
                    'serve-web',
                    '--without-connection-token',
                    '--accept-server-license-terms',
                    '--host', '127.0.0.1',
                    '--port', '8080',
                    '/workshop'  // „ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ„Éï„Ç©„É´„ÉÄ„ÇíÊåáÂÆö
                  ], {
                    stdio: ['ignore', 'pipe', 'pipe'],
                    env: { ...process.env, HOME: '/home/{{ CodeServerUser }}' },
                    cwd: '/workshop'  // ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí/workshop„Å´Ë®≠ÂÆö
                  });
                  
                  vscode.stdout.on('data', (data) => {
                    console.log('VS Code:', data.toString().trim());
                  });
                  
                  vscode.stderr.on('data', (data) => {
                    console.error('VS Code Error:', data.toString().trim());
                  });
                  
                  vscode.on('close', (code) => {
                    console.log('VS Code Server exited with code:', code);
                  });
                  
                  const server = http.createServer((req, res) => {
                    const parsedUrl = url.parse(req.url, true);
                    
                    // OAuth „Ç≥„Éº„É´„Éê„ÉÉ„ÇØ
                    if (parsedUrl.pathname === '/oauth/callback') {
                      const code = parsedUrl.query.code;
                      const error = parsedUrl.query.error;
                      
                      console.log('OAuth callback:', { code: !!code, error });
                      
                      if (error) {
                        console.error('OAuth error:', error);
                        res.writeHead(400, { 'Content-Type': 'text/html' });
                        res.end('<h1>OAuth Error</h1><p>' + error + '</p>');
                        return;
                      }
                      
                      if (!code) {
                        console.error('Missing authorization code');
                        res.writeHead(400, { 'Content-Type': 'text/html' });
                        res.end('<h1>Missing Authorization Code</h1>');
                        return;
                      }
                      
                      const tokenData = querystring.stringify({
                        grant_type: 'authorization_code',
                        client_id: CLIENT_ID,
                        client_secret: CLIENT_SECRET,
                        code: code,
                        redirect_uri: 'https://' + CLOUDFRONT_DOMAIN + '/oauth/callback'
                      });
                      
                      const options = {
                        hostname: USER_POOL_DOMAIN,
                        port: 443,
                        path: '/oauth2/token',
                        method: 'POST',
                        headers: {
                          'Content-Type': 'application/x-www-form-urlencoded',
                          'Content-Length': Buffer.byteLength(tokenData)
                        }
                      };
                      
                      const tokenReq = https.request(options, (tokenRes) => {
                        console.log('Token response status:', tokenRes.statusCode);
                        let data = '';
                        tokenRes.on('data', (chunk) => data += chunk);
                        tokenRes.on('end', () => {
                          console.log('Token response:', data);
                          try {
                            const tokens = JSON.parse(data);
                            if (tokens.access_token) {
                              const sessionId = generateSessionId();
                              sessions.set(sessionId, {
                                created: Date.now(),
                                token: tokens.access_token
                              });
                              
                              console.log('Session created:', sessionId);
                              
                              res.writeHead(302, {
                                'Set-Cookie': 'workshop_session=' + sessionId + '; HttpOnly; Path=/; Max-Age=3600',
                                'Location': '/'
                              });
                              res.end();
                            } else {
                              console.error('No access token in response');
                              res.writeHead(400, { 'Content-Type': 'text/html' });
                              res.end('<h1>Failed to get access token</h1><pre>' + data + '</pre>');
                            }
                          } catch (e) {
                            console.error('Token parsing error:', e);
                            res.writeHead(500, { 'Content-Type': 'text/html' });
                            res.end('<h1>Token exchange failed</h1><p>' + e.message + '</p>');
                          }
                        });
                      });
                      
                      tokenReq.on('error', (e) => {
                        console.error('Token request error:', e);
                        res.writeHead(500, { 'Content-Type': 'text/html' });
                        res.end('<h1>Token exchange error</h1><p>' + e.message + '</p>');
                      });
                      
                      tokenReq.setTimeout(10000, () => {
                        console.error('Token request timeout');
                        tokenReq.destroy();
                        res.writeHead(504, { 'Content-Type': 'text/html' });
                        res.end('<h1>Token request timeout</h1>');
                      });
                      
                      tokenReq.write(tokenData);
                      tokenReq.end();
                      return;
                    }
                    
                    // „É≠„Ç∞„Ç§„É≥„Éö„Éº„Ç∏
                    if (parsedUrl.pathname === '/login') {
                      const loginUrl = 'https://' + USER_POOL_DOMAIN + '/oauth2/authorize?client_id=' + CLIENT_ID + '&response_type=code&scope=openid+email+profile&redirect_uri=https://' + CLOUDFRONT_DOMAIN + '/oauth/callback';
                      res.writeHead(302, { 'Location': loginUrl });
                      res.end();
                      return;
                    }
                    
                    // Health check
                    if (parsedUrl.pathname === '/healthz') {
                      res.writeHead(200, { 'Content-Type': 'application/json' });
                      res.end(JSON.stringify({
                        status: 'alive',
                        timestamp: new Date().toISOString(),
                        sessions: sessions.size,
                        workspace: '/workshop',
                        vscode_running: true
                      }));
                      return;
                    }
                    
                    // Ë™çË®º„ÉÅ„Çß„ÉÉ„ÇØ
                    if (!checkAuth(req)) {
                      console.log('Authentication required, redirecting to login');
                      const loginUrl = 'https://' + USER_POOL_DOMAIN + '/oauth2/authorize?client_id=' + CLIENT_ID + '&response_type=code&scope=openid+email+profile&redirect_uri=https://' + CLOUDFRONT_DOMAIN + '/oauth/callback';
                      res.writeHead(302, { 'Location': loginUrl });
                      res.end();
                      return;
                    }
                    
                    console.log('Authenticated request, proxying to VS Code Server');
                    
                    // VS Code Server„Å∏„Éó„É≠„Ç≠„Ç∑
                    const proxyReq = http.request({
                      hostname: '127.0.0.1',
                      port: 8080,
                      path: req.url,
                      method: req.method,
                      headers: req.headers
                    }, (proxyRes) => {
                      res.writeHead(proxyRes.statusCode, proxyRes.headers);
                      proxyRes.pipe(res);
                    });
                    
                    proxyReq.on('error', (e) => {
                      console.error('Proxy error:', e);
                      res.writeHead(502, { 'Content-Type': 'text/html' });
                      res.end('<h1>VS Code Server Unavailable</h1><p>' + e.message + '</p>');
                    });
                    
                    req.pipe(proxyReq);
                  });
                  
                  server.listen(80, '0.0.0.0', () => {
                    console.log('Simple server listening on port 80');
                  });
                  EOF
                  
                  chown {{ CodeServerUser }}:{{ CodeServerUser }} /home/{{ CodeServerUser }}/simple-server.js
          
          # „Ç∑„É≥„Éó„É´„Çµ„Éº„Éê„Éº„ÅÆÊ∫ñÂÇô
          - name: PrepareSimpleServer
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - echo "Preparing simple server..."
          
          # „Çµ„Éº„Éì„Çπ‰ΩúÊàê„Å®Ëµ∑Âãï
          - name: CreateServices
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 300
              runCommand:
                - '#!/bin/bash'
                - set -e
                - echo "Creating systemd services..."
                - |
                  # „Ç∑„É≥„Éó„É´„Çµ„Éº„Éê„Éº„Çµ„Éº„Éì„Çπ
                  cat > /etc/systemd/system/simple-server.service << 'EOF'
                  [Unit]
                  Description=Simple VS Code Server with Auth
                  After=network.target snapd.service
                  Wants=snapd.service
                  
                  [Service]
                  Type=simple
                  User=root
                  Group=root
                  Environment="HOME=/home/{{ CodeServerUser }}"
                  Environment="COGNITO_CLIENT_ID={{ CognitoClientId }}"
                  Environment="COGNITO_CLIENT_SECRET={{ CognitoClientSecret }}"
                  Environment="COGNITO_USER_POOL_DOMAIN={{ CognitoUserPoolDomain }}"
                  Environment="CLOUDFRONT_DOMAIN={{ CloudFrontDomain }}"
                  Environment="PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"
                  WorkingDirectory=/home/{{ CodeServerUser }}
                  ExecStart=/usr/bin/node simple-server.js
                  Restart=always
                  RestartSec=5
                  StartLimitInterval=60
                  StartLimitBurst=3
                  StandardOutput=journal
                  StandardError=journal
                  TimeoutStartSec=30
                  TimeoutStopSec=10
                  
                  [Install]
                  WantedBy=multi-user.target
                  EOF
                  
                  echo "Reloading systemd and starting services..."
                  systemctl daemon-reload
                  systemctl enable simple-server
                  systemctl start simple-server
                  echo "Service setup completed"
                  
                  # „Çµ„Éº„Éì„ÇπÁä∂ÊÖã„ÇíÁ¢∫Ë™ç„Åó„ÄÅÂøÖË¶Å„Å´Âøú„Åò„Å¶ÂÜçËµ∑Âãï
                  sleep 10
                  if ! systemctl is-active --quiet simple-server; then
                    echo "Service not active, attempting restart..."
                    systemctl restart simple-server
                    sleep 5
                  fi
                  
                  systemctl status simple-server --no-pager
                  
                  # Health check„Åß„Çµ„Éº„Éì„Çπ„ÅÆÂãï‰Ωú„ÇíÁ¢∫Ë™ç
                  echo "Testing service health..."
                  for i in {1..5}; do
                    if curl -s http://localhost/healthz | grep -q '"status":"alive"'; then
                      echo "Service is healthy"
                      break
                    else
                      echo "Attempt $i: Service not ready, waiting..."
                      sleep 2
                    fi
                  done
                  
                  echo "Final service status check completed"
          
          # „Ç¢„Çª„ÉÉ„Éà„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
          - name: DownloadAssets
            action: aws:runShellScript
            inputs:
              timeoutSeconds: 600
              runCommand:
                - '#!/bin/bash'
                - |
                  echo "Setting up workshop directory: {{ HomeFolder }}"
                  
                  # „ÉØ„Éº„ÇØ„Ç∑„Éß„ÉÉ„Éó„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí‰ΩúÊàê
                  mkdir -p {{ HomeFolder }}
                  chown -R {{ CodeServerUser }}:{{ CodeServerUser }} {{ HomeFolder }}
                  chmod 755 {{ HomeFolder }}
                  
                  if [[ -n "{{ AssetZipS3Path }}" ]]; then
                    echo "Downloading workshop assets..."
                    curl -L {{ AssetZipS3Path }} -o /tmp/asset.zip
                    
                    if [[ -f /tmp/asset.zip ]]; then
                      echo "Extracting assets to {{ HomeFolder }}..."
                      unzip -o /tmp/asset.zip -d {{ HomeFolder }}
                      chown -R {{ CodeServerUser }}:{{ CodeServerUser }} {{ HomeFolder }}
                      
                      # Git„É™„Éù„Ç∏„Éà„É™„ÅÆÂàùÊúüÂåñ
                      if [[ -d {{ HomeFolder }}/.git ]]; then
                        sudo -u {{ CodeServerUser }} git -C {{ HomeFolder }} add .
                        sudo -u {{ CodeServerUser }} git -C {{ HomeFolder }} commit -m 'Workshop commit' || true
                      else
                        sudo -u {{ CodeServerUser }} git -C {{ HomeFolder }} init
                        sudo -u {{ CodeServerUser }} git -C {{ HomeFolder }} add .
                        sudo -u {{ CodeServerUser }} git -C {{ HomeFolder }} commit -m 'Initial commit' || true
                      fi
                      
                      echo "Workshop assets setup completed"
                    else
                      echo "Failed to download assets, creating basic structure"
                      sudo -u {{ CodeServerUser }} touch {{ HomeFolder }}/README.md
                      echo "# Workshop Environment" > {{ HomeFolder }}/README.md
                      chown {{ CodeServerUser }}:{{ CodeServerUser }} {{ HomeFolder }}/README.md
                    fi
                  else
                    echo "No assets specified, creating basic workshop structure"
                    sudo -u {{ CodeServerUser }} touch {{ HomeFolder }}/README.md
                    echo "# Workshop Environment" > {{ HomeFolder }}/README.md
                    chown {{ CodeServerUser }}:{{ CodeServerUser }} {{ HomeFolder }}/README.md
                  fi
                  
                  # ÊúÄÁµÇÁ¢∫Ë™ç
                  ls -la {{ HomeFolder }}
                  echo "Workshop directory setup completed"

  # SSMÂÆüË°åÁî®Lambda
  SSMDocLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: !Sub lambda.${AWS::URLSuffix}
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SSMDocOnEC2Policy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ssm:SendCommand
                Resource:
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:document/${CodeServerSSMDoc}
                  - !Sub arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:instance/${CodeServerInstance}
              - Effect: Allow
                Action:
                  - ssm:ListCommandInvocations
                  - ssm:GetCommandInvocation
                Resource: '*'

  RunSSMDocLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Run SSM document on EC2 instance
      Handler: index.lambda_handler
      Runtime: python3.11
      MemorySize: 128
      Timeout: 900
      Role: !GetAtt SSMDocLambdaRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def lambda_handler(event, context):
              if event['RequestType'] != 'Create':
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='No action to take')
                  return
              
              try:
                  resource_properties = event['ResourceProperties']
                  instance_id = resource_properties['InstanceId']
                  document_name = resource_properties['DocumentName']
                  
                  parameters = {}
                  for key, value in resource_properties.items():
                      if key not in ['ServiceToken', 'ServiceTimeout', 'InstanceId', 'DocumentName']:
                          parameters[key] = [value]
                  
                  ssm = boto3.client('ssm')
                  response = ssm.send_command(
                      InstanceIds=[instance_id],
                      DocumentName=document_name,
                      Parameters=parameters
                  )
                  
                  command_id = response['Command']['CommandId']
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {'CommandId': command_id}, reason='OK')
                  
              except Exception as e:
                  logger.error(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=str(e))

  CodeServerInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !If
        - IsGraviton
        - !FindInMap [ArmImage, !Ref InstanceOperatingSystem, ImageId]
        - !FindInMap [AmdImage, !Ref InstanceOperatingSystem, ImageId]
      InstanceType: !Ref InstanceType
      BlockDeviceMappings:
        - DeviceName: !If [IsAL2023, /dev/xvda, /dev/sda1]
          Ebs:
            VolumeSize: !Ref InstanceVolumeSize
            VolumeType: gp3
            DeleteOnTermination: true
            Encrypted: true
      SecurityGroupIds:
        - !Ref SecurityGroup
      IamInstanceProfile: !Ref CodeServerInstanceProfile
      Tags:
        - Key: Name
          Value: !Ref InstanceName


  RunCodeServerSSMDoc:
    Type: Custom::RunSSMDocLambda
    DependsOn: 
      - SetPermanentPassword
      - GetClientSecret
      - UpdateCognitoClient
    Properties:
      ServiceToken: !GetAtt RunSSMDocLambda.Arn
      InstanceId: !Ref CodeServerInstance
      DocumentName: !Ref CodeServerSSMDoc
      LinuxFlavor: 'ubuntu'
      CodeServerUser: !Ref CodeServerUser
      CognitoClientId: !Ref CognitoUserPoolClient
      CognitoClientSecret: !GetAtt GetClientSecret.ClientSecret
      CognitoUserPoolDomain: !Sub ${CognitoUserPoolDomain}.auth.${AWS::Region}.amazoncognito.com
      CloudFrontDomain: !GetAtt CloudFrontDistribution.DomainName
      DevServerBasePath: !Ref DevServerBasePath
      DevServerPort: !Ref DevServerPort
      HomeFolder: !Ref HomeFolder
      AssetZipS3Path: !Ref AssetZipS3Path

Outputs:
  # üéØ „Åì„Çå„Å†„ÅëË¶ã„Çå„Å∞OKÔºÅ
  WorkshopURL:
    Description: "üöÄ Workshop VS Code Server URL - Click to start!"
    Value: !Sub https://${CloudFrontDistribution.DomainName}/?folder=${HomeFolder}
  
  LoginCredentials:
    Description: "üîë Login with these credentials"
    Value: !Sub |
      Email: ${AdminEmail}
      Password: ${AdminPassword}
  
  CognitoLoginURL:
    Description: "üîê Direct Cognito Login URL"
    Value: !Sub https://${CognitoUserPoolDomain}.auth.${AWS::Region}.amazoncognito.com/oauth2/authorize?client_id=${CognitoUserPoolClient}&response_type=code&scope=openid+email+profile&redirect_uri=https://${CloudFrontDistribution.DomainName}/oauth/callback
  
  # Ë©≥Á¥∞ÊÉÖÂ†±
  CognitoDetails:
    Description: "üìã Auto-created Cognito details"
    Value: !Sub |
      User Pool ID: ${CognitoUserPool}
      User Pool Domain: ${CognitoUserPoolDomain}.auth.${AWS::Region}.amazoncognito.com
      App Client ID: ${CognitoUserPoolClient}
      Admin User: ${AdminEmail}
  
  QuickStart:
    Description: "‚ö° Quick Start Guide"
    Value: !Sub |
      1. Wait for stack creation to complete (5-10 minutes)
      2. Click the WorkshopURL above
      3. Login with: ${AdminEmail} / ${AdminPassword}
      4. Start coding in VS Code Server!
  
  Configuration:
    Description: "‚öôÔ∏è Configuration Summary"
    Value: !Sub |
      Authentication: Auto-generated Cognito User Pool
      Session Duration: 1 hour
      Security: Workshop-optimized
      CloudFront Domain: ${CloudFrontDistribution.DomainName}
      Instance Type: ${InstanceType}